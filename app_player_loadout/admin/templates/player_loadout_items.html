<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <title>Loadout de itens do jogador</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body class="container py-4">
    <h2>Loadout de <span id="playerName">{{ player.PlayerName or player.PlayerID }}</span></h2>

    <div id="groupedItemsGrid" class="mb-5"></div>
    <div id="noItemsMsg" class="alert alert-warning d-none mt-3">Nenhum item configurado para este jogador.</div>

    <div class="mb-3">
        <input type="text" id="itemSearchInput" class="form-control" placeholder="Buscar itens por nome..." oninput="loadAvailableItemsGrouped()">
    </div>

    <h4>Itens disponíveis</h4>
    <div id="availableItemsContainer" class="mb-4"></div>

    <script>
        const playerId = "{{ player.PlayerID }}";
        const ITEMS_PER_PAGE = 6;
        const groupPageState = {}; // paginação por tipo

        window.onload = async () => {
            await loadPlayerItems();
            await loadAvailableItemsGrouped();
        };

        async function fetchJSON(url, options = {}) {
            const res = await fetch(url, options);
            if (!res.ok) {
                const err = await res.json().catch(() => ({}));
                throw new Error(err.error || 'Erro desconhecido');
            }
            return res.json();
        }

        function localizationParse(localization) {
            switch (localization) {
                case "head":
                    return "Cabeça";
                case "eyes":
                    return "Olhos";
                case "face":
                    return "Rosto";
                case "torso":
                    return "Torso";
                case "foot":
                    return "Pés";
                case "back":
                    return "Costas";
                case "waist":
                    return "Cintura";
                case "hands":
                    return "Mãos";
                case "":
                case null:
                case undefined:
                    return "Não possui";
                default:
                    return localization; // retorna o valor original se não for mapeado
            }
        }

        async function loadPlayerItems() {
            const container = document.getElementById('groupedItemsGrid');
            const msg = document.getElementById('noItemsMsg');
            container.innerHTML = '';

            try {
                const items = await fetchJSON(`/players/${playerId}/items`);
                msg.classList.toggle('d-none', items.length > 0);
                console.log("items",items)
                const grouped = {};
                for (const item of items) {
                    const key = item.localization || 'outros';
                    if (!grouped[key]) grouped[key] = [];
                    grouped[key].push(item);
                    
                }

                for (const [loc, locItems] of Object.entries(grouped)) {
                    const section = document.createElement('div');
                    section.innerHTML = `<h5>${localizationParse(loc)}</h5>`;
                    const row = document.createElement('div');
                    row.className = 'd-flex flex-row flex-nowrap overflow-auto gap-3 mb-3';

                    locItems.forEach(item => {
                        
                        const card = document.createElement('div');
                        card.className = 'card p-2 text-center';
                        card.style.minWidth = '160px';
                        const armazenamento = item.storage_slots > 0
                            ? `${item.storage_width}x${item.storage_height} (${item.storage_slots} slots)`
                            : "Não possui";

                        card.innerHTML = `
                            <img src="${item.img}" class="card-img-top mx-auto" style="max-height: 100px; object-fit: contain;">
                            <div class="card-body p-2">
                                <h6 class="card-title small">${item.name}</h6>
                                <p class="small text-muted">${item.name_type}</p>
                                <p class="small m-0">${item.width}x${item.height} (${item.slots} slots)</p>
                                <p class="small m-0">Armazenamento: ${armazenamento}</p>
                                <div class="d-flex justify-content-between align-items-center mt-3">
                                    <div class="input-group" style="max-width: 130px;">
                                        <button class="btn btn-sm btn-outline-secondary" onclick="updateItemQuantity(${item.id}, -1)">
                                            <i class="fas fa-minus"></i>
                                        </button>
                                        <input class="form-control form-control-sm text-center" value="${item.quantity}" disabled>
                                        <button class="btn btn-sm btn-outline-secondary" onclick="updateItemQuantity(${item.id}, 1)">
                                            <i class="fas fa-plus"></i>
                                        </button>
                                    </div>
                                    <button class="btn btn-sm btn-outline-danger ms-2" onclick="removeItemFromPlayer(${item.id})">
                                        Remover
                                    </button>
                                </div>
                            </div>
                        `;
                        row.appendChild(card);
                    });

                    section.appendChild(row);
                    container.appendChild(section);
                }

            } catch (err) {
                msg.classList.remove('d-none');
                msg.textContent = 'Erro ao carregar itens do jogador.';
            }
        }

        async function removeItemFromPlayer(itemId) {
            if (!confirm('Remover este item do jogador?')) return;

            try {
                await fetchJSON(`/players/${playerId}/items/${itemId}`, { method: 'DELETE' });
                await loadPlayerItems();
                await loadAvailableItemsGrouped();
            } catch (err) {
                alert('Erro ao remover item: ' + err.message);
            }
        }

        async function loadAvailableItemsGrouped() {
            const searchTerm = document.getElementById('itemSearchInput').value.trim().toLowerCase();
            const allItems = await fetchJSON('/items');
            const playerItems = await fetchJSON(`/players/${playerId}/items`);
            const countMap = {};

            for (const item of playerItems) {
                countMap[item.id] = (countMap[item.id] || 0) + 1;
            }

            const grouped = {};
            for (const item of allItems) {
                if (searchTerm && !item.name.toLowerCase().includes(searchTerm)) continue;

                if (!grouped[item.type_name]) grouped[item.type_name] = [];
                grouped[item.type_name].push(item);
            }

            const container = document.getElementById('availableItemsContainer');
            container.innerHTML = '';

            for (const [typeName, items] of Object.entries(grouped)) {
                const currentPage = groupPageState[typeName] || 1;
                const totalPages = Math.ceil(items.length / ITEMS_PER_PAGE);
                const pageItems = items.slice((currentPage - 1) * ITEMS_PER_PAGE, currentPage * ITEMS_PER_PAGE);

                const section = document.createElement('div');
                section.innerHTML = `<h5 class="mb-2">${typeName}</h5>`;
                const row = document.createElement('div');
                row.className = 'd-flex flex-row flex-nowrap overflow-auto gap-3';

                for (const item of pageItems) {
                    const count = countMap[item.id] || 0;

                    // Aqui podemos aplicar futuras regras
                    const allowMultiple = true; // <- Ponto de controle futuro

                    const card = document.createElement('div');
                    card.className = 'card p-2 text-center';
                    card.style.minWidth = '160px';
                    card.innerHTML = `
                        <img src="${item.img}" class="card-img-top mx-auto" alt="${item.name}" style="max-height: 100px; object-fit: contain;">
                        <div class="card-body p-2">
                            <h6 class="card-title small">${item.name}</h6>
                            ${count > 0 ? `<p class="small text-muted mb-1">Já adicionado!</p>` : ''}
                            <button class="btn btn-sm btn-primary mt-1" onclick="addItemToPlayerDirect(${item.id})" ${count > 0 ? 'disabled' : ''}>
                                Adicionar
                            </button>
                        </div>
                    `;
                    row.appendChild(card);
                }

                section.appendChild(row);

                // Paginação por tipo
                if (totalPages > 1) {
                    const pagination = document.createElement('div');
                    pagination.className = 'mt-2 d-flex gap-2';

                    const prev = document.createElement('button');
                    prev.className = 'btn btn-sm btn-outline-secondary';
                    prev.textContent = 'Anterior';
                    prev.disabled = currentPage === 1;
                    prev.onclick = () => {
                        groupPageState[typeName] = currentPage - 1;
                        loadAvailableItemsGrouped();
                    };

                    const next = document.createElement('button');
                    next.className = 'btn btn-sm btn-outline-secondary';
                    next.textContent = 'Próxima';
                    next.disabled = currentPage === totalPages;
                    next.onclick = () => {
                        groupPageState[typeName] = currentPage + 1;
                        loadAvailableItemsGrouped();
                    };

                    pagination.appendChild(prev);
                    pagination.appendChild(document.createTextNode(` Página ${currentPage} de ${totalPages} `));
                    pagination.appendChild(next);
                    section.appendChild(pagination);
                }

                container.appendChild(section);
            }
        }

        async function addItemToPlayerDirect(itemId) {
            try {
                await fetchJSON(`/players/${playerId}/items`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ item_id: itemId })
                });
                await loadPlayerItems();
                await loadAvailableItemsGrouped();
            } catch (err) {
                alert('Erro ao adicionar item: ' + err.message);
            }
        }
        async function updateItemQuantity(itemId, delta) {
            try {
                await fetchJSON(`/players/${playerId}/items/${itemId}/quantity`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ delta })
                });
                await loadPlayerItems();
                await loadAvailableItemsGrouped();
            } catch (err) {
                alert('Erro ao atualizar quantidade: ' + err.message);
            }
        }

    </script>
</body>
</html>
